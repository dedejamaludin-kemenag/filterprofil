(function () {
  const { createClient } = supabase;

  // KONFIGURASI SUPABASE
  const SUPABASE_URL = "https://unhacmkhjawhoizdctdk.supabase.co";
  const SUPABASE_ANON_KEY =
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVuaGFjbWtoamF3aG9pemRjdGRrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU4MjczOTMsImV4cCI6MjA4MTQwMzM5M30.oKIm1s9gwotCeZVvS28vOCLddhIN9lopjG-YeaULMtk";

  const db = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  // Storage & tabel pendamping (SOP/IK + Record Bukti)
  // Catatan: pastikan tabel & bucket sudah dibuat (lihat file sql/migrations_program_docs_records.sql)
  const STORAGE_BUCKET = "pontren_docs"; // bisa diganti sesuai bucket antum
  const DOCS_TABLE = "program_pontren_docs";
  const RECORDS_TABLE = "program_pontren_records";

  // Cache Element DOM
  const els = {
    profil: document.getElementById("f_profil"),
    indikator: document.getElementById("f_indikator"),
    program: document.getElementById("f_program"),
    bukti: document.getElementById("f_bukti"),
    frekuensi: document.getElementById("f_frekuensi"),
    sop: document.getElementById("f_sop"),
    instruksi_kerja: document.getElementById("f_instruksi_kerja"),
    
    pic: document.getElementById("f_pic"),
    q: document.getElementById("q"),
    btnApply: document.getElementById("btn_apply"),
    btnReset: document.getElementById("btn_reset"),
    btnAddData: document.getElementById("btnAddData"),
    tbody: document.getElementById("tbody"),
    cards: document.getElementById("cards"),
    count: document.getElementById("count"),
    status: document.getElementById("status"),
    statusDot: document.getElementById("statusDot"),
    filtersPanel: document.getElementById("filtersPanel"),
    fileExcel: document.getElementById("fileExcel"),
    
    // Modal Edit
    modal: document.getElementById("editModal"),
    modalTitle: document.getElementById("modalTitle"),
    btnCloseModal: document.getElementById("btnCloseModal"),
    btnCancelEdit: document.getElementById("btnCancelEdit"),
    btnSaveEdit: document.getElementById("btnSaveEdit"),
    btnDeleteData: document.getElementById("btnDeleteData"),
    
    // Form Inputs
    e_id: document.getElementById("e_id"),
    e_profil: document.getElementById("e_profil"),
    e_definisi: document.getElementById("e_definisi"),
    e_indikator: document.getElementById("e_indikator"),
    e_program: document.getElementById("e_program"),
    e_sasaran: document.getElementById("e_sasaran"),
    e_bukti: document.getElementById("e_bukti"),
    e_frekuensi: document.getElementById("e_frekuensi"),
    e_pic: document.getElementById("e_pic"),
    e_sop: document.getElementById("e_sop"),
    e_instruksi_kerja: document.getElementById("e_instruksi_kerja"),

    // Quick link: kelola dokumen (SOP/IK/Record)
    btnManageDocs: document.getElementById("btnManageDocs"),

    // Modal Dokumen & Record
    docsModal: document.getElementById("docsModal"),
    docsModalTitle: document.getElementById("docsModalTitle"),
    docsModalSubtitle: document.getElementById("docsModalSubtitle"),
    btnCloseDocsModal: document.getElementById("btnCloseDocsModal"),

    tabBtnSOP: document.getElementById("tabBtnSOP"),
    tabBtnIK: document.getElementById("tabBtnIK"),
    tabBtnREC: document.getElementById("tabBtnREC"),
    tabPanelSOP: document.getElementById("tabPanelSOP"),
    tabPanelIK: document.getElementById("tabPanelIK"),
    tabPanelREC: document.getElementById("tabPanelREC"),

    // Input SOP
    doc_title: document.getElementById("doc_title"),
    doc_no: document.getElementById("doc_no"),
    doc_revision: document.getElementById("doc_revision"),
    doc_effective: document.getElementById("doc_effective"),
    doc_notes: document.getElementById("doc_notes"),
    doc_file: document.getElementById("doc_file"),
    doc_tpl_file: document.getElementById("doc_tpl_file"),
    sopParsePreview: document.getElementById("sopParsePreview"),
    // Actions SOP (merged)
    btnTplSOP: document.getElementById("btnTplSOP"),
    menuTplSOP: document.getElementById("menuTplSOP"),
    btnTemplateSOPPrefill: document.getElementById("btnTemplateSOPPrefill"),
    sop_smart_file: document.getElementById("sop_smart_file"),
    btnUploadSOPSmart: document.getElementById("btnUploadSOPSmart"),
    docsListSOP: document.getElementById("docsListSOP"),

    // Input IK
    ik_title: document.getElementById("ik_title"),
    ik_no: document.getElementById("ik_no"),
    ik_revision: document.getElementById("ik_revision"),
    ik_effective: document.getElementById("ik_effective"),
    ik_notes: document.getElementById("ik_notes"),
    ik_file: document.getElementById("ik_file"),
    ik_tpl_file: document.getElementById("ik_tpl_file"),
    ikParsePreview: document.getElementById("ikParsePreview"),
    // Actions IK (merged)
    btnTplIK: document.getElementById("btnTplIK"),
    menuTplIK: document.getElementById("menuTplIK"),
    btnTemplateIKPrefill: document.getElementById("btnTemplateIKPrefill"),
    ik_smart_file: document.getElementById("ik_smart_file"),
    btnUploadIKSmart: document.getElementById("btnUploadIKSmart"),
    docsListIK: document.getElementById("docsListIK"),

    // Record bukti
    rec_date: document.getElementById("rec_date"),
    rec_title: document.getElementById("rec_title"),
    rec_desc: document.getElementById("rec_desc"),
    rec_file: document.getElementById("rec_file"),
    rec_tpl_file: document.getElementById("rec_tpl_file"),
    recParsePreview: document.getElementById("recParsePreview"),
    // Actions REC (merged-ish)
    btnTplREC: document.getElementById("btnTplREC"),
    menuTplREC: document.getElementById("menuTplREC"),
    btnTemplateRECPrefill: document.getElementById("btnTemplateRECPrefill"),
    btnRecAddMenu: document.getElementById("btnRecAddMenu"),
    menuRecAdd: document.getElementById("menuRecAdd"),
    rec_smart_file: document.getElementById("rec_smart_file"),
    btnImportREC: document.getElementById("btnImportREC"),
    btnAddRecord: document.getElementById("btnAddRecord"),
    recordsList: document.getElementById("recordsList"),

    // Toast & Confirm
    toastContainer: document.getElementById("toastContainer"),
    confirmModal: document.getElementById("confirmModal"),
    confirmText: document.getElementById("confirmText"),
    btnConfirmYes: document.getElementById("btnConfirmYes"),
    btnConfirmNo: document.getElementById("btnConfirmNo"),
  };

  // master data (dari DB), dan data yang sedang ditampilkan
  let allRowsData = [];
  let viewRowsData = [];

  // state modal dokumen
  let activeProgramRow = null;
  let docsCountsByProgram = new Map(); // program_id -> { sop: n, ik: n, rec: n }
  let warnedMissingDocsTables = false;
  let lastDocsTab = "SOP";

  // Normalisasi string
  function norm(x) {
    return (x ?? "").toString().trim();
  }

  function normLower(x) {
    return norm(x).toLowerCase();
  }

  // --- NOTIFICATION SYSTEM (TOAST) ---
  function notify(msg, type = "info") {
    const toast = document.createElement("div");
    toast.className = `toast ${type}`;
    
    let icon = "info";
    if (type === "success") icon = "check-circle";
    if (type === "error") icon = "warning-circle";

    toast.innerHTML = `<i class="ph ph-${icon}"></i> <span>${msg}</span>`;
    
    els.toastContainer.appendChild(toast);

    // Auto remove after 4s
    setTimeout(() => {
      toast.style.opacity = "0";
      setTimeout(() => toast.remove(), 300);
    }, 4000);
  }

  // --- CUSTOM CONFIRM MODAL ---
  function askConfirm(message) {
    return new Promise((resolve) => {
      els.confirmText.textContent = message;
      els.confirmModal.classList.add("open");

      // Handler untuk tombol
      const handleYes = () => {
        cleanup();
        resolve(true);
      };
      
      const handleNo = () => {
        cleanup();
        resolve(false);
      };

      // Cleanup event listeners agar tidak menumpuk
      function cleanup() {
        els.btnConfirmYes.removeEventListener("click", handleYes);
        els.btnConfirmNo.removeEventListener("click", handleNo);
        els.confirmModal.classList.remove("open");
      }

      els.btnConfirmYes.addEventListener("click", handleYes);
      els.btnConfirmNo.addEventListener("click", handleNo);
    });
  }

  // Utils
  function safeText(x) {
    return (x ?? "").toString().replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }

  // --- BADGE HELPERS (kolom PIC) ---
  function renderPicBadges(value) {
    const s = norm(value);
    const empty = s ? "" : " is-empty";
    if (!s) return `<span class="pill-badge pic${empty}" title="—">—</span>`;

    // Pecah multi-PIC: koma / titik-koma / baris baru
    const parts = s
      .split(/[\n;,]+/)
      .map(x => x.trim())
      .filter(Boolean);

    if (!parts.length) return `<span class="pill-badge pic is-empty" title="—">—</span>`;

    return parts
      .slice(0, 6) // batasi agar tabel tetap rapih
      .map(p => `<span class="pill-badge pic" title="${safeText(p)}">${safeText(p)}</span>`)
      .join("");
  }

  function excerptText(x, maxLen = 140) {
    const s = norm(x);
    if (!s) return "-";
    if (s.length <= maxLen) return s;
    return s.slice(0, Math.max(0, maxLen - 1)) + "…";
  }

  function setStatus(msg, state = "ok") {
    els.status.textContent = msg;
    els.statusDot.className = "dot " + state;
    const loading = state === "load";
    [els.btnApply, els.btnReset].forEach(b => b.disabled = loading);
    els.btnApply.style.opacity = loading ? "0.7" : "1";
    document.body.style.cursor = loading ? "wait" : "default";
  }

  function setOptions(selectEl, items) {
    if (!selectEl) return;
    const current = selectEl.value;
    selectEl.innerHTML = '<option value="">Semua</option>';
    const arr = (items || []).filter(v => v != null && String(v).trim() !== "");
    arr.forEach(v => {
      const opt = document.createElement("option");
      opt.value = String(v);
      opt.textContent = String(v);
      selectEl.appendChild(opt);
    });
    if (arr.some(v => String(v) === current)) selectEl.value = current;
  }

  function readFilters() {
  return {
    profil: norm(els.profil.value),
    indikator: norm(els.indikator.value),
    program: els.program.value.trim(),
    pic: els.pic.value.trim(),
    q: els.q.value.trim(),
  };
}

  // --- MODAL & DATA LOGIC ---
  function openModal(row) {
    // simpan row aktif untuk tombol kelola dokumen/bukti
    activeProgramRow = row || null;

    if (row) {
      els.modalTitle.textContent = "Edit Data";
      els.e_id.value = row.id;
      els.e_profil.value = row.profil || row.profil_utama || "";
      els.e_definisi.value = row.definisi || "";
      els.e_indikator.value = row.indikator || "";
      els.e_program.value = row.program || "";
      els.e_sasaran.value = row.sasaran || "";
      els.e_sop.value = row.sop || "";
      els.e_instruksi_kerja.value = row.instruksi_kerja || "";
      els.e_bukti.value = row.bukti || "";
      els.e_frekuensi.value = row.frekuensi || "";
      els.e_pic.value = row.pic || "";
      els.btnDeleteData.classList.remove("hidden");

      // tombol kelola dokumen aktif
      [els.btnManageDocs].forEach(b => {
        if (!b) return;
        b.disabled = false;
        b.style.opacity = "1";
      });
    } else {
      els.modalTitle.textContent = "Tambah Data Baru";
      els.e_id.value = "";
      els.e_profil.value = "";
      els.e_definisi.value = "";
      els.e_indikator.value = "";
      els.e_program.value = "";
      els.e_sasaran.value = "";
      els.e_sop.value = "";
      els.e_instruksi_kerja.value = "";
      els.e_bukti.value = "";
      els.e_frekuensi.value = "";
      els.e_pic.value = "";
      els.btnDeleteData.classList.add("hidden");

      // tombol kelola dokumen nonaktif sampai data dibuat
      [els.btnManageDocs].forEach(b => {
        if (!b) return;
        b.disabled = true;
        b.style.opacity = "0.6";
      });
    }
    els.modal.classList.add("open");
  }

  function closeModal() {
    els.modal.classList.remove("open");
  }

  // --- DOKUMEN (SOP/IK) & RECORD BUKTI ---
  function sanitizeFileName(name) {
    return String(name || "file")
      .replace(/[^a-zA-Z0-9._-]+/g, "_")
      .replace(/^_+|_+$/g, "")
      .slice(0, 160);
  }

  function nowKey() {
    const d = new Date();
    const pad = (n) => String(n).padStart(2, "0");
    return `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
  }

  function buildStoragePath(programId, kind, fileName) {
    // kind: SOP | IK | REC
    const safe = sanitizeFileName(fileName);
    return `program_pontren/${programId}/${kind}/${nowKey()}_${safe}`;
  }

  async function getFileUrl(path) {
    // 1) coba signed url (kalau bucket privat)
    try {
      const { data, error } = await db.storage.from(STORAGE_BUCKET).createSignedUrl(path, 60 * 60);
      if (!error && data?.signedUrl) return data.signedUrl;
    } catch (_) {}

    // 2) fallback public url (kalau bucket publik)
    const { data } = db.storage.from(STORAGE_BUCKET).getPublicUrl(path);
    return data?.publicUrl || "";
  }

  function setDocsTab(tab) {
    lastDocsTab = tab || "SOP";
    const allBtns = [els.tabBtnSOP, els.tabBtnIK, els.tabBtnREC];
    const allPanels = [els.tabPanelSOP, els.tabPanelIK, els.tabPanelREC];
    allBtns.forEach(b => b && b.classList.remove("active"));
    allPanels.forEach(p => p && p.classList.remove("active"));

    if (tab === "SOP") {
      els.tabBtnSOP?.classList.add("active");
      els.tabPanelSOP?.classList.add("active");
    } else if (tab === "IK") {
      els.tabBtnIK?.classList.add("active");
      els.tabPanelIK?.classList.add("active");
    } else {
      els.tabBtnREC?.classList.add("active");
      els.tabPanelREC?.classList.add("active");
    }
  }

  function openDocsModal(row, initialTab = "SOP") {
    if (!row || !row.id) {
      notify("Data belum punya ID. Simpan dulu datanya, baru bisa lampirkan dokumen/bukti.", "error");
      return;
    }
    activeProgramRow = row;
    els.docsModalTitle.textContent = "Dokumen & Bukti";
    const profil = row.profil || row.profil_utama || "-";
    const program = row.program || "-";
    els.docsModalSubtitle.textContent = `${profil} • ${program}`;
    setDocsTab(initialTab);
    els.docsModal.classList.add("open");
    loadDocsAndRecords();
  }

  function closeDocsModal() {
    els.docsModal.classList.remove("open");
  }

  async function safeSelect(table, queryFn) {
    try {
      const q = queryFn(db.from(table));
      const res = await q;
      if (res?.error) throw res.error;
      return res?.data || [];
    } catch (err) {
      // Table belum dibuat? Jangan bikin app crash.
      if (!warnedMissingDocsTables) {
        warnedMissingDocsTables = true;
        notify("Tabel dokumen/record belum ada. Jalankan SQL migration dulu (lihat folder sql).", "error");
      }
      return [];
    }
  }

  async function loadDocsAndRecords() {
    if (!activeProgramRow?.id) return;

    const pid = activeProgramRow.id;

    // load docs
    const docs = await safeSelect(DOCS_TABLE, (t) =>
      t.select("*").eq("program_id", pid).order("created_at", { ascending: false })
    );

    // load records
    const recs = await safeSelect(RECORDS_TABLE, (t) =>
      t.select("*").eq("program_id", pid).order("record_date", { ascending: false })
    );

    renderDocsList(docs, "SOP", els.docsListSOP);
    renderDocsList(docs, "IK", els.docsListIK);
    renderRecordsList(recs, els.recordsList);

    // update counts cache & chips
    updateCountsCacheFromLists(pid, docs, recs);
    updateChipCountsInDom();
  }

  // ----------------------------
  // TEMPLATE XLSX (ISI OTOMATIS)
  // ----------------------------
  function safeFilePart(s) {
    return norm(s)
      .replace(/\s+/g, "_")
      .replace(/[^a-zA-Z0-9_\-\.]/g, "_")
      .slice(0, 80) || "dokumen";
  }

  function setCellPreserveStyle(ws, addr, value) {
    const v = value == null ? "" : String(value);
    const cell = ws[addr] || {};
    // pertahankan style (jika ada)
    const style = cell.s;
    ws[addr] = { ...cell, v, t: "s", s: style };
  }

  async function downloadTemplatePrefilled(kind) {
    if (!activeProgramRow?.id) {
      notify("Buka dulu data programnya, baru bisa download template isi otomatis.", "error");
      return;
    }

    const row = activeProgramRow;
    const profil = row.profil || row.profil_utama || "";
    const program = row.program || "";
    const sasaran = row.sasaran || "";
    const pic = row.pic || "";
    const frekuensi = row.frekuensi || "";

    let templateUrl = "";
    let filename = "";

    // ambil metadata dari input box (kalau kosong, auto-isi)
    const today = new Date().toISOString().slice(0, 10);

    if (kind === "SOP") {
      templateUrl = "./templates/Template_SOP.xlsx";
      const title = norm(els.doc_title?.value) || (program ? `SOP ${program}` : "SOP");
      const no = norm(els.doc_no?.value);
      const rev = norm(els.doc_revision?.value);
      const eff = norm(els.doc_effective?.value) || today;

      filename = `TEMPLATE_SOP_${safeFilePart(program || profil)}_${eff}.xlsx`;

      const buf = await fetch(templateUrl).then(r => r.arrayBuffer());
      const wb = XLSX.read(buf, { type: "array" });
      const ws = wb.Sheets[wb.SheetNames[0]];

      // Identitas (kolom B)
      setCellPreserveStyle(ws, "B5", no);
      setCellPreserveStyle(ws, "B6", title);
      setCellPreserveStyle(ws, "B7", rev);
      setCellPreserveStyle(ws, "B8", eff);
      setCellPreserveStyle(ws, "B9", pic);

      // Isi ringkas agar nyambung dengan data program
      setCellPreserveStyle(
        ws,
        "B15",
        program && sasaran ? `Melaksanakan program: ${program} untuk mencapai sasaran: ${sasaran}.` : (program ? `Melaksanakan program: ${program}.` : "")
      );
      setCellPreserveStyle(
        ws,
        "B16",
        profil ? `Profil/Area: ${profil}${frekuensi ? ` (Frekuensi: ${frekuensi})` : ""}` : (frekuensi ? `Frekuensi: ${frekuensi}` : "")
      );
      setCellPreserveStyle(ws, "B18", "ISO 21001:2025 dan ketentuan internal lembaga");
      setCellPreserveStyle(ws, "B19", pic ? `PIC pelaksana: ${pic}` : "");

      const out = XLSX.write(wb, { bookType: "xlsx", type: "array" });
      triggerDownload(out, filename);
      return;
    }

    if (kind === "IK") {
      templateUrl = "./templates/Template_IK.xlsx";
      const title = norm(els.ik_title?.value) || (program ? `IK ${program}` : "IK");
      const no = norm(els.ik_no?.value);
      const rev = norm(els.ik_revision?.value);
      const eff = norm(els.ik_effective?.value) || today;

      filename = `TEMPLATE_IK_${safeFilePart(program || profil)}_${eff}.xlsx`;

      const buf = await fetch(templateUrl).then(r => r.arrayBuffer());
      const wb = XLSX.read(buf, { type: "array" });
      const ws = wb.Sheets[wb.SheetNames[0]];

      setCellPreserveStyle(ws, "B5", no);
      setCellPreserveStyle(ws, "B6", title);
      setCellPreserveStyle(ws, "B7", rev);
      setCellPreserveStyle(ws, "B8", eff);
      setCellPreserveStyle(ws, "B9", pic);

      setCellPreserveStyle(ws, "B14", program ? `Digunakan saat menjalankan program: ${program}.` : "");
      setCellPreserveStyle(ws, "B15", "Perangkat kerja sesuai kebutuhan (aplikasi / form / dokumen pendukung)");
      setCellPreserveStyle(ws, "B16", "Sesuai role yang ditetapkan (Admin/UPMP/Unit terkait)");

      const out = XLSX.write(wb, { bookType: "xlsx", type: "array" });
      triggerDownload(out, filename);
      return;
    }

    // RECORD
    templateUrl = "./templates/Template_Record.xlsx";
    const rdate = norm(els.rec_date?.value) || today;
    const rtitle = norm(els.rec_title?.value) || (program ? `Record ${program}` : "Record");
    const rdesc = norm(els.rec_desc?.value);
    filename = `TEMPLATE_RECORD_${safeFilePart(program || profil)}_${rdate}.xlsx`;

    const buf = await fetch(templateUrl).then(r => r.arrayBuffer());
    const wb = XLSX.read(buf, { type: "array" });
    const ws = wb.Sheets[wb.SheetNames[0]];

    // Identitas form
    setCellPreserveStyle(ws, "B5", rtitle);
    setCellPreserveStyle(ws, "B6", "");
    setCellPreserveStyle(ws, "B7", "Rev.01");
    setCellPreserveStyle(ws, "B8", pic);
    setCellPreserveStyle(ws, "B10", "Arsip Digital (Drive/Storage) / Arsip Fisik (jika ada)");
    setCellPreserveStyle(ws, "B11", "Sesuai ketentuan retensi lembaga");
    setCellPreserveStyle(ws, "B12", "Internal");

    // Isi 1 baris log awal (row 16)
    setCellPreserveStyle(ws, "A16", rdate);
    setCellPreserveStyle(ws, "B16", program);
    setCellPreserveStyle(ws, "C16", rtitle);
    setCellPreserveStyle(ws, "D16", rdesc);
    setCellPreserveStyle(ws, "F16", pic);
    setCellPreserveStyle(ws, "H16", "Draft");

    const out = XLSX.write(wb, { bookType: "xlsx", type: "array" });
    triggerDownload(out, filename);
  }

  function triggerDownload(arrayBuffer, filename) {
    const blob = new Blob([arrayBuffer], {
      type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // ----------------------------
  // PARSE TEMPLATE XLSX (UPLOAD + PREFILL INPUT)
  // ----------------------------
  function getFileExt(nameOrPath) {
    const s = norm(nameOrPath).toLowerCase();
    const m = s.match(/\.([a-z0-9]+)(?:\?|#|$)/i);
    return m ? m[1] : "";
  }

  function isTemplateXlsx(nameOrPath) {
    const ext = getFileExt(nameOrPath);
    return ext === "xlsx" || ext === "xls" || ext === "xlsm";
  }

  function excelDateToISO(v) {
    if (!v && v !== 0) return "";
    // Sudah ISO
    if (typeof v === "string") {
      const s = v.trim();
      if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
      // Kadang dd/mm/yyyy
      const m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
      if (m) {
        const dd = String(m[1]).padStart(2, "0");
        const mm = String(m[2]).padStart(2, "0");
        return `${m[3]}-${mm}-${dd}`;
      }
      return s;
    }
    if (typeof v === "number") {
      const d = XLSX.SSF.parse_date_code(v);
      if (!d || !d.y) return "";
      const mm = String(d.m).padStart(2, "0");
      const dd = String(d.d).padStart(2, "0");
      return `${d.y}-${mm}-${dd}`;
    }
    return "";
  }

  function getCell(ws, addr) {
    const c = ws?.[addr];
    return c ? c.v : "";
  }

  async function parseSopIkTemplate(file, kind) {
    const buf = await file.arrayBuffer();
    const wb = XLSX.read(buf, { type: "array" });
    const ws = wb.Sheets[wb.SheetNames[0]];

    const doc_no = norm(getCell(ws, "B5"));
    const title = norm(getCell(ws, "B6"));
    const revision = norm(getCell(ws, "B7"));
    const effective_date = excelDateToISO(getCell(ws, "B8"));
    const pic = norm(getCell(ws, "B9"));

    // ringkasan isi (opsional): ambil beberapa sel yang memang kita isi saat prefill
    const ringkas1 = norm(getCell(ws, kind === "SOP" ? "B15" : "B14"));
    const ringkas2 = norm(getCell(ws, kind === "SOP" ? "B16" : "B15"));
    const ringkas3 = norm(getCell(ws, kind === "SOP" ? "B19" : "B16"));
    const notes_from_file = [ringkas1, ringkas2, ringkas3].filter(Boolean).join("\n");

    return { title, doc_no, revision, effective_date, pic, notes_from_file };
  }

  function showParsePreview(previewEl, meta, extraHtml = "") {
    if (!previewEl) return;
    previewEl.style.display = "block";
    previewEl.innerHTML = `
      <div><strong>Hasil Parse</strong></div>
      <div style="margin-top:6px">
        ${meta.doc_no ? `<div>No Dok: <strong>${safeText(meta.doc_no)}</strong></div>` : ""}
        ${meta.title ? `<div>Judul: <strong>${safeText(meta.title)}</strong></div>` : ""}
        ${meta.revision ? `<div>Revisi: <strong>${safeText(meta.revision)}</strong></div>` : ""}
        ${meta.effective_date ? `<div>Berlaku: <strong>${safeText(meta.effective_date)}</strong></div>` : ""}
        ${meta.pic ? `<div>PIC (dari template): <strong>${safeText(meta.pic)}</strong></div>` : ""}
      </div>
      ${extraHtml}
    `;
  }

  function hideParsePreview(previewEl) {
    if (!previewEl) return;
    previewEl.style.display = "none";
    previewEl.innerHTML = "";
  }

  async function uploadTemplateParsed(docType, fileOverride = null) {
    if (!activeProgramRow?.id) return;
    const pid = activeProgramRow.id;
    const isSOP = docType === "SOP";
    const fileEl = isSOP ? els.doc_tpl_file : els.ik_tpl_file;
    const previewEl = isSOP ? els.sopParsePreview : els.ikParsePreview;
    const file = fileOverride || fileEl?.files?.[0];
    if (!file) {
      notify("Pilih file template XLSX dulu.", "error");
      return;
    }

    setStatus("Parsing template...", "load");
    try {
      const meta = await parseSopIkTemplate(file, docType);

      // isi input box (boleh diedit sebelum simpan)
      if (isSOP) {
        if (meta.title) els.doc_title.value = meta.title;
        if (meta.doc_no) els.doc_no.value = meta.doc_no;
        if (meta.revision) els.doc_revision.value = meta.revision;
        if (meta.effective_date) els.doc_effective.value = meta.effective_date;
        if (!norm(els.doc_notes.value) && meta.notes_from_file) els.doc_notes.value = meta.notes_from_file;
      } else {
        if (meta.title) els.ik_title.value = meta.title;
        if (meta.doc_no) els.ik_no.value = meta.doc_no;
        if (meta.revision) els.ik_revision.value = meta.revision;
        if (meta.effective_date) els.ik_effective.value = meta.effective_date;
        if (!norm(els.ik_notes.value) && meta.notes_from_file) els.ik_notes.value = meta.notes_from_file;
      }

      showParsePreview(previewEl, meta);

      const ok = await askConfirm(`Upload template ${docType} ini dan simpan sebagai sumber (XLSX)?`);
      if (!ok) {
        setStatus("Ready", "ok");
        return;
      }

      setStatus("Uploading...", "load");
      const path = buildStoragePath(pid, docType, file.name);
      const { error: upErr } = await db.storage.from(STORAGE_BUCKET).upload(path, file, { upsert: false });
      if (upErr) throw upErr;

      // payload seperti dokumen biasa, tapi kita tandai sebagai sumber template
      const title = norm(isSOP ? els.doc_title.value : els.ik_title.value);
      const doc_no = norm(isSOP ? els.doc_no.value : els.ik_no.value);
      const revision = norm(isSOP ? els.doc_revision.value : els.ik_revision.value);
      const effective_date = (isSOP ? els.doc_effective.value : els.ik_effective.value) || null;
      const notesRaw = norm(isSOP ? els.doc_notes.value : els.ik_notes.value);
      const notes = (notesRaw ? notesRaw + "\n" : "") + "[SOURCE_XLSX]";

      const payload = {
        program_id: pid,
        doc_type: docType,
        title: title || null,
        doc_no: doc_no || null,
        revision: revision || null,
        effective_date,
        notes,
        file_path: path,
        is_active: true,
      };
      const { error: insErr } = await db.from(DOCS_TABLE).insert(payload);
      if (insErr) throw insErr;

      // reset
      if (!fileOverride && fileEl) fileEl.value = "";
      notify(`Template ${docType} berhasil diupload & diparse.`, "success");
      await loadDocsAndRecords();
      await refreshCountsForViewRows();
    } catch (err) {
      console.error(err);
      notify("Gagal parse/upload template: " + (err?.message || String(err)), "error");
    } finally {
      setStatus("Ready", "ok");
    }
  }

  async function parseRecordTemplate(file) {
    const buf = await file.arrayBuffer();
    const wb = XLSX.read(buf, { type: "array" });
    const ws = wb.Sheets[wb.SheetNames[0]];
    const rows = XLSX.utils.sheet_to_json(ws, { header: 1, raw: true });

    // Cari header tabel log (kolom A = Tanggal)
    let headerIdx = -1;
    for (let i = 0; i < Math.min(rows.length, 60); i++) {
      const a = norm(rows[i]?.[0]);
      if (/tanggal/i.test(a)) {
        headerIdx = i;
        break;
      }
    }
    const start = headerIdx >= 0 ? headerIdx + 1 : 15; // fallback

    const parsed = [];
    for (let i = start; i < rows.length; i++) {
      const r = rows[i] || [];
      const dateISO = excelDateToISO(r[0]);
      const program = norm(r[1]);
      const title = norm(r[2]);
      const desc = norm(r[3]);
      const pic = norm(r[5]);
      if (!dateISO && !title && !desc && !program) {
        // stop kalau sudah kosong beruntun
        continue;
      }
      if (!dateISO) continue; // tanggal wajib

      parsed.push({
        record_date: dateISO,
        title: title || (program ? `Record ${program}` : "Record"),
        description: desc || (program ? `Program: ${program}${pic ? ` • PIC: ${pic}` : ""}` : (pic ? `PIC: ${pic}` : "")),
      });
    }

    // identitas ringkas dari sel B5 (judul), B8 (PIC)
    const identTitle = norm(getCell(ws, "B5"));
    const identPIC = norm(getCell(ws, "B8"));

    return { identTitle, identPIC, parsed };
  }

  async function uploadRecordTemplateParsed(fileOverride = null) {
    if (!activeProgramRow?.id) return;
    const pid = activeProgramRow.id;
    const file = fileOverride || els.rec_tpl_file?.files?.[0];
    if (!file) {
      notify("Pilih file Template Record XLSX dulu.", "error");
      return;
    }

    setStatus("Parsing template record...", "load");
    try {
      const { identTitle, identPIC, parsed } = await parseRecordTemplate(file);
      const count = parsed.length;
      if (!count) {
        hideParsePreview(els.recParsePreview);
        notify("Tidak menemukan baris record yang valid. Pastikan kolom Tanggal terisi.", "error");
        setStatus("Ready", "ok");
        return;
      }

      // prefill input ringkas kalau masih kosong
      if (!norm(els.rec_title.value) && identTitle) els.rec_title.value = identTitle;
      if (!norm(els.rec_desc.value) && identPIC) els.rec_desc.value = `PIC (dari template): ${identPIC}`;

      const previewRows = parsed.slice(0, 4).map(p => `<div>• <strong>${safeText(p.record_date)}</strong> — ${safeText(p.title)}</div>`).join("");
      showParsePreview(els.recParsePreview, { title: identTitle, doc_no: "", revision: "", effective_date: "", pic: identPIC }, `<div style="margin-top:8px">Ditemukan <strong>${count}</strong> record.</div><div style="margin-top:6px">${previewRows}${count > 4 ? `<div style=\"margin-top:6px\">…dan ${count - 4} record lainnya</div>` : ""}</div>`);

      const ok = await askConfirm(`Tambah ${count} record dari template ini?`);
      if (!ok) {
        setStatus("Ready", "ok");
        return;
      }

      setStatus("Uploading template & saving records...", "load");
      // Upload file template sebagai bukti sumber (opsional) dan attach ke semua record
      const path = buildStoragePath(pid, "REC", file.name);
      const { error: upErr } = await db.storage.from(STORAGE_BUCKET).upload(path, file, { upsert: false });
      if (upErr) throw upErr;

      // Insert records (batch)
      const payloads = parsed.map(p => ({
        program_id: pid,
        record_date: p.record_date,
        title: p.title,
        description: p.description,
        file_path: path, // bukti sumber template
      }));

      const { error: insErr } = await db.from(RECORDS_TABLE).insert(payloads);
      if (insErr) throw insErr;

      // reset
      if (!fileOverride) els.rec_tpl_file.value = "";
      notify("Record dari template berhasil ditambahkan.", "success");
      await loadDocsAndRecords();
      await refreshCountsForViewRows();
    } catch (err) {
      console.error(err);
      notify("Gagal parse/upload record: " + (err?.message || String(err)), "error");
    } finally {
      setStatus("Ready", "ok");
    }
  }

  function docGroupKey(d) {
    const k = [
      norm(d.doc_no),
      norm(d.revision),
      norm(d.effective_date),
      norm(d.title),
    ].join("|");
    // fallback agar tidak kosong total
    return k !== "|||" ? k : norm(d.file_path) || String(d.id);
  }

  function countDocGroups(docs, docType) {
    const set = new Set();
    (docs || [])
      .filter(d => d.doc_type === docType)
      .forEach(d => set.add(docGroupKey(d)));
    return set.size;
  }

  function updateCountsCacheFromLists(pid, docs, recs) {
    const sop = countDocGroups(docs, "SOP");
    const ik = countDocGroups(docs, "IK");
    const rec = (recs || []).length;
    docsCountsByProgram.set(String(pid), { sop, ik, rec });
  }

  async function refreshCountsForViewRows() {
    const ids = (viewRowsData || []).map(r => r.id).filter(Boolean);
    if (!ids.length) {
      updateChipCountsInDom();
      return;
    }

    const docs = await safeSelect(DOCS_TABLE, (t) =>
      t.select("program_id,doc_type,doc_no,revision,effective_date,title,file_path").in("program_id", ids)
    );
    const recs = await safeSelect(RECORDS_TABLE, (t) =>
      t.select("program_id").in("program_id", ids)
    );

    const map = new Map();
    ids.forEach(id => map.set(String(id), { sop: 0, ik: 0, rec: 0 }));
    // hitung unik per kelompok dokumen (agar SOURCE+FINAL tidak jadi dobel)
    const groupMap = new Map();
    ids.forEach(id => groupMap.set(String(id), { sop: new Set(), ik: new Set() }));

    (docs || []).forEach(d => {
      const pid = String(d.program_id);
      if (!groupMap.has(pid)) groupMap.set(pid, { sop: new Set(), ik: new Set() });
      const key = docGroupKey(d);
      if (d.doc_type === "SOP") groupMap.get(pid).sop.add(key);
      if (d.doc_type === "IK") groupMap.get(pid).ik.add(key);
    });

    groupMap.forEach((sets, pid) => {
      if (!map.has(pid)) map.set(pid, { sop: 0, ik: 0, rec: 0 });
      map.get(pid).sop = sets.sop.size;
      map.get(pid).ik = sets.ik.size;
    });
    (recs || []).forEach(r => {
      const key = String(r.program_id);
      if (!map.has(key)) map.set(key, { sop: 0, ik: 0, rec: 0 });
      map.get(key).rec += 1;
    });

    docsCountsByProgram = map;
    updateChipCountsInDom();
  }

  function updateChipCountsInDom() {
    // update semua span count yang punya data-program-id
    document.querySelectorAll("[data-chip-count]").forEach((el) => {
      const pid = el.getAttribute("data-program-id");
      const kind = el.getAttribute("data-kind"); // sop|ik|rec
      const c = docsCountsByProgram.get(String(pid)) || { sop: 0, ik: 0, rec: 0 };
      const v = kind === "ik" ? c.ik : kind === "rec" ? c.rec : c.sop;
      el.textContent = String(v);
    });
  }

  function renderDocsList(docs, docType, container) {
    if (!container) return;
    const list = (docs || []).filter(d => d.doc_type === docType);
    if (!list.length) {
      container.innerHTML = `<div style="padding:14px; color:var(--text-muted)">Belum ada dokumen ${docType}.</div>`;
      return;
    }

    // Group berdasarkan identitas dokumen (agar SOURCE_XLSX dan FINAL PDF/DOCX tampil 1 baris)
    const groups = new Map();
    list.forEach(d => {
      const k = docGroupKey(d);
      if (!groups.has(k)) groups.set(k, []);
      groups.get(k).push(d);
    });

    // sort: group yang terbaru di atas (pakai created_at terbaru dari anggota group)
    const groupArr = Array.from(groups.entries()).map(([k, arr]) => {
      const newest = arr
        .map(x => x.created_at || x.updated_at || "")
        .sort()
        .slice(-1)[0] || "";
      return { k, arr, newest };
    }).sort((a, b) => (a.newest < b.newest ? 1 : -1));

    container.innerHTML = groupArr.map(({ arr }) => {
      const ids = arr.map(x => x.id).filter(Boolean);
      const idsCsv = ids.join(",");
      const anyActive = arr.some(x => !!x.is_active);

      // pilih source xlsx dan final non-xlsx (ambil yang paling baru)
      const sorted = [...arr].sort((a, b) => (String(a.created_at) < String(b.created_at) ? 1 : -1));
      const source = sorted.find(x => isTemplateXlsx(x.file_path)) || null;
      const final = sorted.find(x => !isTemplateXlsx(x.file_path)) || null;
      const main = final || source || sorted[0];

      const title = safeText(main.title || (docType === "SOP" ? "Dokumen SOP" : "Dokumen IK"));
      const sub = [
        main.doc_no ? `No: ${safeText(main.doc_no)}` : null,
        main.revision ? `Revisi: ${safeText(main.revision)}` : null,
        main.effective_date ? `Berlaku: ${safeText(main.effective_date)}` : null,
        anyActive ? "Aktif" : "Arsip",
      ].filter(Boolean).join(" • ");

      const parts = [];
      if (final) parts.push(`<button class="link-btn" type="button" data-doc-view="${final.id}"><i class="ph ph-eye"></i> Lihat Final</button>`);
      if (source) parts.push(`<button class="link-btn" type="button" data-doc-view="${source.id}"><i class="ph ph-file-arrow-up"></i> Lihat Source</button>`);
      if (!final && !source) parts.push(`<button class="link-btn" type="button" data-doc-view="${main.id}"><i class="ph ph-eye"></i> Lihat</button>`);

      parts.push(
        `<button class="link-btn" type="button" data-doc-toggle-group="${idsCsv}">${anyActive ? '<i class="ph ph-archive"></i> Arsip' : '<i class="ph ph-check"></i> Aktifkan'}</button>`
      );
      parts.push(`<button class="link-btn danger" type="button" data-doc-del-group="${idsCsv}"><i class="ph ph-trash"></i></button>`);

      return `
        <div class="file-row">
          <div class="file-left">
            <div class="file-title">${title}</div>
            <div class="file-sub">${sub}</div>
          </div>
          <div class="file-actions">
            ${parts.join("")}
          </div>
        </div>
      `;
    }).join("");
  }

  function renderRecordsList(recs, container) {
    if (!container) return;
    const list = recs || [];
    if (!list.length) {
      container.innerHTML = `<div style="padding:14px; color:var(--text-muted)">Belum ada record bukti.</div>`;
      return;
    }

    container.innerHTML = list.map(r => {
      const title = safeText(r.title || "Record");
      const date = safeText(r.record_date || "-");
      const desc = safeText(r.description || "");
      const sub = desc ? `${date} • ${desc}` : date;
      return `
        <div class="file-row">
          <div class="file-left">
            <div class="file-title">${title}</div>
            <div class="file-sub">${sub}</div>
          </div>
          <div class="file-actions">
            ${r.file_path ? '<button class="link-btn" type="button" data-rec-view="' + r.id + '"><i class="ph ph-eye"></i> Lihat</button>' : ''}
            <button class="link-btn danger" type="button" data-rec-del="${r.id}"><i class="ph ph-trash"></i></button>
          </div>
        </div>
      `;
    }).join("");
  }

  async function uploadDoc(docType, fileOverride = null) {
    if (!activeProgramRow?.id) return;
    const pid = activeProgramRow.id;

    const isSOP = docType === "SOP";
    const title = norm(isSOP ? els.doc_title.value : els.ik_title.value);
    const doc_no = norm(isSOP ? els.doc_no.value : els.ik_no.value);
    const revision = norm(isSOP ? els.doc_revision.value : els.ik_revision.value);
    const effective_date = (isSOP ? els.doc_effective.value : els.ik_effective.value) || null;
    const notesRaw = norm(isSOP ? els.doc_notes.value : els.ik_notes.value);
    const fileEl = isSOP ? els.doc_file : els.ik_file;
    const file = fileOverride || fileEl?.files?.[0];
    if (!file) {
      notify("Pilih file dulu.", "error");
      return;
    }

    const ok = await askConfirm(`Upload dokumen ${docType} untuk program ini?`);
    if (!ok) return;

    setStatus("Uploading...", "load");
    try {
      const path = buildStoragePath(pid, docType, file.name);
      const { error: upErr } = await db.storage.from(STORAGE_BUCKET).upload(path, file, { upsert: false });
      if (upErr) throw upErr;

      const kindTag = isTemplateXlsx(file.name) ? "[SOURCE_XLSX]" : "[FINAL]";
      const notes = (notesRaw ? notesRaw + "\n" : "") + kindTag;

      const payload = {
        program_id: pid,
        doc_type: docType,
        title: title || null,
        doc_no: doc_no || null,
        revision: revision || null,
        effective_date,
        notes: notes || null,
        file_path: path,
        is_active: true,
      };

      const { error: insErr } = await db.from(DOCS_TABLE).insert(payload);
      if (insErr) throw insErr;

      // reset inputs
      if (!fileOverride) {
        if (isSOP) {
          els.doc_file.value = "";
        } else {
          els.ik_file.value = "";
        }
      }

      notify(`Dokumen ${docType} berhasil diupload.`, "success");
      await loadDocsAndRecords();
      await refreshCountsForViewRows();
    } catch (err) {
      console.error(err);
      notify("Gagal upload: " + (err?.message || String(err)), "error");
    } finally {
      setStatus("Ready", "ok");
    }
  }

  async function addRecord() {
    if (!activeProgramRow?.id) return;
    const pid = activeProgramRow.id;

    const record_date = els.rec_date.value || null;
    if (!record_date) {
      notify("Tanggal record wajib diisi.", "error");
      return;
    }
    const title = norm(els.rec_title.value) || null;
    const description = norm(els.rec_desc.value) || null;
    const file = els.rec_file?.files?.[0] || null;

    const ok = await askConfirm("Tambah record bukti untuk program ini?");
    if (!ok) return;

    setStatus("Saving...", "load");
    try {
      let file_path = null;
      if (file) {
        const path = buildStoragePath(pid, "REC", file.name);
        const { error: upErr } = await db.storage.from(STORAGE_BUCKET).upload(path, file, { upsert: false });
        if (upErr) throw upErr;
        file_path = path;
      }

      const payload = {
        program_id: pid,
        record_date,
        title,
        description,
        file_path,
      };
      const { error: insErr } = await db.from(RECORDS_TABLE).insert(payload);
      if (insErr) throw insErr;

      // reset inputs
      els.rec_title.value = "";
      els.rec_desc.value = "";
      els.rec_file.value = "";

      notify("Record bukti ditambahkan.", "success");
      await loadDocsAndRecords();
      await refreshCountsForViewRows();
    } catch (err) {
      console.error(err);
      notify("Gagal tambah record: " + (err?.message || String(err)), "error");
    } finally {
      setStatus("Ready", "ok");
    }
  }

  async function toggleDocActive(docId) {
    const ok = await askConfirm("Ubah status dokumen ini? (Aktif/Arsip)");
    if (!ok) return;
    setStatus("Updating...", "load");
    try {
      // ambil status sekarang
      const { data, error } = await db.from(DOCS_TABLE).select("id,is_active").eq("id", docId).single();
      if (error) throw error;
      const next = !data.is_active;
      const { error: upErr } = await db.from(DOCS_TABLE).update({ is_active: next }).eq("id", docId);
      if (upErr) throw upErr;
      notify("Status dokumen diperbarui.", "success");
      await loadDocsAndRecords();
      await refreshCountsForViewRows();
    } catch (err) {
      console.error(err);
      notify("Gagal update: " + (err?.message || String(err)), "error");
    } finally {
      setStatus("Ready", "ok");
    }
  }

  async function deleteDoc(docId) {
    const ok = await askConfirm("Hapus dokumen ini? (file & data akan dihapus)");
    if (!ok) return;
    setStatus("Deleting...", "load");
    try {
      const { data, error } = await db.from(DOCS_TABLE).select("id,file_path").eq("id", docId).single();
      if (error) throw error;
      if (data?.file_path) {
        await db.storage.from(STORAGE_BUCKET).remove([data.file_path]);
      }
      const { error: delErr } = await db.from(DOCS_TABLE).delete().eq("id", docId);
      if (delErr) throw delErr;
      notify("Dokumen dihapus.", "success");
      await loadDocsAndRecords();
      await refreshCountsForViewRows();
    } catch (err) {
      console.error(err);
      notify("Gagal hapus: " + (err?.message || String(err)), "error");
    } finally {
      setStatus("Ready", "ok");
    }
  }

  async function toggleDocActiveGroup(idsCsv) {
    const ids = (idsCsv || "").split(",").map(x => x.trim()).filter(Boolean);
    if (!ids.length) return;
    const ok = await askConfirm("Ubah status dokumen ini? (Aktif/Arsip)");
    if (!ok) return;
    setStatus("Updating...", "load");
    try {
      const { data, error } = await db.from(DOCS_TABLE).select("id,is_active").in("id", ids);
      if (error) throw error;
      const anyActive = (data || []).some(x => !!x.is_active);
      const next = !anyActive;
      const { error: upErr } = await db.from(DOCS_TABLE).update({ is_active: next }).in("id", ids);
      if (upErr) throw upErr;
      notify("Status dokumen diperbarui.", "success");
      await loadDocsAndRecords();
      await refreshCountsForViewRows();
    } catch (err) {
      console.error(err);
      notify("Gagal update: " + (err?.message || String(err)), "error");
    } finally {
      setStatus("Ready", "ok");
    }
  }

  async function deleteDocGroup(idsCsv) {
    const ids = (idsCsv || "").split(",").map(x => x.trim()).filter(Boolean);
    if (!ids.length) return;
    const ok = await askConfirm("Hapus dokumen ini? (semua file SOURCE/FINAL akan dihapus)");
    if (!ok) return;
    setStatus("Deleting...", "load");
    try {
      const { data, error } = await db.from(DOCS_TABLE).select("id,file_path").in("id", ids);
      if (error) throw error;
      const paths = (data || []).map(x => x.file_path).filter(Boolean);
      if (paths.length) {
        await db.storage.from(STORAGE_BUCKET).remove(paths);
      }
      const { error: delErr } = await db.from(DOCS_TABLE).delete().in("id", ids);
      if (delErr) throw delErr;
      notify("Dokumen dihapus.", "success");
      await loadDocsAndRecords();
      await refreshCountsForViewRows();
    } catch (err) {
      console.error(err);
      notify("Gagal hapus: " + (err?.message || String(err)), "error");
    } finally {
      setStatus("Ready", "ok");
    }
  }

  async function deleteRecord(recId) {
    const ok = await askConfirm("Hapus record ini?");
    if (!ok) return;
    setStatus("Deleting...", "load");
    try {
      const { data, error } = await db.from(RECORDS_TABLE).select("id,file_path").eq("id", recId).single();
      if (error) throw error;
      if (data?.file_path) {
        await db.storage.from(STORAGE_BUCKET).remove([data.file_path]);
      }
      const { error: delErr } = await db.from(RECORDS_TABLE).delete().eq("id", recId);
      if (delErr) throw delErr;
      notify("Record dihapus.", "success");
      await loadDocsAndRecords();
      await refreshCountsForViewRows();
    } catch (err) {
      console.error(err);
      notify("Gagal hapus: " + (err?.message || String(err)), "error");
    } finally {
      setStatus("Ready", "ok");
    }
  }

  async function viewDoc(docId) {
    try {
      const { data, error } = await db.from(DOCS_TABLE).select("file_path").eq("id", docId).single();
      if (error) throw error;
      const url = await getFileUrl(data.file_path);
      if (!url) throw new Error("URL file kosong. Cek bucket/storage policy.");
      window.open(url, "_blank");
    } catch (err) {
      notify("Gagal buka dokumen: " + (err?.message || String(err)), "error");
    }
  }

  async function viewRecord(recId) {
    try {
      const { data, error } = await db.from(RECORDS_TABLE).select("file_path").eq("id", recId).single();
      if (error) throw error;
      if (!data?.file_path) throw new Error("Record tidak punya lampiran.");
      const url = await getFileUrl(data.file_path);
      if (!url) throw new Error("URL file kosong. Cek bucket/storage policy.");
      window.open(url, "_blank");
    } catch (err) {
      notify("Gagal buka record: " + (err?.message || String(err)), "error");
    }
  }

  async function saveChanges() {
    const id = els.e_id.value;
    const dataToSave = {
      profil: norm(els.e_profil.value),
      definisi: els.e_definisi.value.trim(),
      indikator: els.e_indikator.value.trim(),
      program: els.e_program.value.trim(),
      sasaran: els.e_sasaran.value.trim(),
      sop: els.e_sop.value.trim(),
      instruksi_kerja: els.e_instruksi_kerja.value.trim(),
      bukti: norm(els.e_bukti.value),
      frekuensi: norm(els.e_frekuensi.value),
      pic: els.e_pic.value.trim(),
    };

    const hasData = Object.values(dataToSave).some(val => val !== "");
    if (!hasData) {
      notify("Harap isi minimal 1 kolom!", "error");
      return;
    }

    if (id) {
      const confirm = await askConfirm("Simpan perubahan pada data ini?");
      if (!confirm) return;

      setStatus("Menyimpan...", "load");
      dataToSave.updated_at = new Date();
      const { error } = await db.from("program_pontren").update(dataToSave).eq("id", id);
      
      if (error) {
        notify("Gagal update: " + error.message, "error");
        setStatus("Gagal", "err");
      } else {
        closeModal();
        notify("Data berhasil diperbarui!", "success");
        await refreshAllData();
        fetchData();
      }
    } else {
      setStatus("Menambahkan...", "load");
      const { error } = await db.from("program_pontren").insert(dataToSave);
      
      if (error) {
        notify("Gagal tambah: " + error.message, "error");
        setStatus("Gagal", "err");
      } else {
        closeModal();
        notify("Data baru berhasil ditambahkan!", "success");
        await refreshAllData();
        fetchData();
      }
    }
  }

  async function deleteData() {
    const id = els.e_id.value;
    if (!id) return;
    
    const confirm = await askConfirm("PERINGATAN: Apakah Anda yakin ingin menghapus data ini secara permanen?");
    if (!confirm) return;

    setStatus("Menghapus...", "load");
    const { error } = await db.from("program_pontren").delete().eq("id", id);
    
    if (error) {
      notify("Gagal hapus: " + error.message, "error");
      setStatus("Gagal", "err");
    } else {
      closeModal();
      notify("Data berhasil dihapus.", "success");
      await refreshAllData();
      fetchData();
    }
  }

  // --- DATA LOADING (tanpa RPC) ---
  async function refreshAllData() {
    setStatus("Syncing...", "load");
    const { data, error } = await db
      .from("program_pontren")
      .select("*")
      .order("profil", { ascending: true })
      .order("program", { ascending: true });

    if (error) {
      notify("Gagal ambil data: " + error.message, "error");
      setStatus("Error", "err");
      allRowsData = [];
      return;
    }
    allRowsData = data || [];
    setStatus("Ready", "ok");
  }

  function uniqueSorted(values) {
    const set = new Set((values || []).map(v => norm(v)).filter(Boolean));
    return Array.from(set).sort((a, b) => a.localeCompare(b, 'id'));
  }

  function applyFilters(rows, f, skipKey = null) {
  const q = normLower(f.q);

  return (rows || []).filter(r => {
    // Hanya 4 filter yang aktif: Profil, Indikator, Program, PIC
    if (skipKey !== "profil" && f.profil && norm(r.profil || r.profil_utama) !== f.profil) return false;
    if (skipKey !== "indikator" && f.indikator && norm(r.indikator) !== f.indikator) return false;
    if (skipKey !== "program" && f.program && norm(r.program) !== f.program) return false;
    if (skipKey !== "pic" && f.pic && norm(r.pic) !== norm(f.pic)) return false;

    // Search (q) tetap nyapu semua kolom (biar enak)
    if (!q) return true;

    const hay = [
      r.profil || r.profil_utama,
      r.definisi,
      r.indikator,
      r.program,
      r.sasaran,
      r.pic,
      r.frekuensi,
      r.sop,
      r.instruksi_kerja,
      r.bukti,
    ].map(normLower).join(" | ");

    return hay.includes(q);
  });
}

  function updateFilterOptions(f) {
  const rowsForProfil = applyFilters(allRowsData, f, "profil");
  const rowsForIndikator = applyFilters(allRowsData, f, "indikator");
  const rowsForProgram = applyFilters(allRowsData, f, "program");
  const rowsForPic = applyFilters(allRowsData, f, "pic");

  setOptions(els.profil, uniqueSorted(rowsForProfil.map(r => r.profil || r.profil_utama)));
  setOptions(els.indikator, uniqueSorted(rowsForIndikator.map(r => r.indikator)));
  setOptions(els.program, uniqueSorted(rowsForProgram.map(r => r.program)));
  setOptions(els.pic, uniqueSorted(rowsForPic.map(r => r.pic)));
}

  function renderRows(rows) {
    viewRowsData = rows || [];
    els.count.textContent = String(viewRowsData.length || 0);
    const empty = `<div style="padding:40px;text-align:center;color:var(--text-muted)">Data tidak ditemukan.</div>`;

    if (!viewRowsData.length) {
      els.tbody.innerHTML = `<tr><td colspan="10">${empty}</td></tr>`;
      els.cards.innerHTML = empty;
      return;
    }

    els.tbody.innerHTML = viewRowsData.map((r, i) => {
      const pid = r.id;
      return `
  <tr data-index="${i}">
    <td>${i + 1}</td>
    <td><span class="cell-profil">${safeText(r.profil || r.profil_utama || "-")}</span><span class="cell-def">${safeText(r.definisi || "-")}</span></td>
    <td>${safeText(r.indikator || "-")}</td>
    <td>${safeText(r.program || "-")}</td>
    <td>${safeText(r.sasaran || "-")}</td>
    <td><div class="badge-wrap">${renderPicBadges(r.pic)}</div></td>
    <td>${safeText(r.frekuensi || "-")}</td>
    <td>
      <div class="cell-excerpt">${safeText(excerptText(r.sop || "-"))}</div>
      <div class="mini-chips">
        <button class="chip-btn" type="button" data-open-docs="SOP" data-index="${i}">
          <span class="chip-dot sop"></span> SOP: <span class="chip-count" data-chip-count data-kind="sop" data-program-id="${pid}">0</span>
        </button>
      </div>
    </td>
    <td>
      <div class="cell-excerpt">${safeText(excerptText(r.instruksi_kerja || "-"))}</div>
      <div class="mini-chips">
        <button class="chip-btn" type="button" data-open-docs="IK" data-index="${i}">
          <span class="chip-dot ik"></span> IK: <span class="chip-count" data-chip-count data-kind="ik" data-program-id="${pid}">0</span>
        </button>
      </div>
    </td>
    <td>
      <div class="cell-excerpt">${safeText(excerptText(r.bukti || "-"))}</div>
      <div class="mini-chips">
        <button class="chip-btn" type="button" data-open-docs="REC" data-index="${i}">
          <span class="chip-dot rec"></span> Record: <span class="chip-count" data-chip-count data-kind="rec" data-program-id="${pid}">0</span>
        </button>
      </div>
    </td>
  </tr>
`;
    }).join("");

    els.cards.innerHTML = viewRowsData.map((r, i) => `
  <div class="m-card" data-index="${i}">
    <div class="m-header">
      <div class="m-title">${safeText(r.profil || r.profil_utama || "-")}</div>
      <div class="m-sub">${safeText(r.definisi || "-")}</div>
    </div>
    <div class="m-row"><div class="m-label">Indikator</div><div>${safeText(r.indikator || "-")}</div></div>
    <div class="m-row"><div class="m-label">Program</div><div>${safeText(r.program || "-")}</div></div>
    <div class="m-row"><div class="m-label">Sasaran</div><div>${safeText(r.sasaran || "-")}</div></div>
    <div class="m-row"><div class="m-label">PIC</div><div><div class="badge-wrap">${renderPicBadges(r.pic)}</div></div></div>
    <div class="m-row"><div class="m-label">Frekuensi</div><div>${safeText(r.frekuensi || "-")}</div></div>
    <div class="m-row"><div class="m-label">SOP</div><div>
      <div class="cell-excerpt">${safeText(excerptText(r.sop || "-", 200))}</div>
      <div class="mini-chips">
        <button class="chip-btn" type="button" data-open-docs="SOP" data-index="${i}">
          <span class="chip-dot sop"></span> SOP: <span class="chip-count" data-chip-count data-kind="sop" data-program-id="${r.id}">0</span>
        </button>
      </div>
    </div></div>
    <div class="m-row"><div class="m-label">Instruksi Kerja</div><div>
      <div class="cell-excerpt">${safeText(excerptText(r.instruksi_kerja || "-", 200))}</div>
      <div class="mini-chips">
        <button class="chip-btn" type="button" data-open-docs="IK" data-index="${i}">
          <span class="chip-dot ik"></span> IK: <span class="chip-count" data-chip-count data-kind="ik" data-program-id="${r.id}">0</span>
        </button>
      </div>
    </div></div>
    <div class="m-row"><div class="m-label">Bukti</div><div>
      <div class="cell-excerpt">${safeText(excerptText(r.bukti || "-", 200))}</div>
      <div class="mini-chips">
        <button class="chip-btn" type="button" data-open-docs="REC" data-index="${i}">
          <span class="chip-dot rec"></span> Record: <span class="chip-count" data-chip-count data-kind="rec" data-program-id="${r.id}">0</span>
        </button>
      </div>
    </div></div>
  </div>
`).join("");

    document.querySelectorAll('tr[data-index]').forEach(row => {
      row.addEventListener('click', () => openModal(viewRowsData[row.getAttribute('data-index')]));
    });
    
    document.querySelectorAll('.m-card[data-index]').forEach(card => {
      card.addEventListener('click', () => openModal(viewRowsData[card.getAttribute('data-index')]));
    });

    // tombol chip (buka dokumen/record) - jangan trigger openModal
    document.querySelectorAll('[data-open-docs]').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const idx = Number(btn.getAttribute('data-index'));
        const tab = btn.getAttribute('data-open-docs') || "SOP";
        openDocsModal(viewRowsData[idx], tab);
      });
    });

    // refresh counts untuk chip
    refreshCountsForViewRows();
  }

  function fetchData() {
    const f = readFilters();
    updateFilterOptions(f);
    const rows = applyFilters(allRowsData, f, null);
    renderRows(rows);
    setStatus("Ready", "ok");
  }

  function resetFilters() {
  els.profil.value = "";
  els.indikator.value = "";
  els.program.value = "";
  els.pic.value = "";
  els.q.value = "";
  fetchData();
}

  // --- IMPORT EXCEL (Robust Sasaran Mapping) ---
function normHeader(s) {
  return String(s ?? "")
    .trim()
    .toLowerCase()
    .replace(/[^\w]+/g, "_")
    .replace(/^_+|_+$/g, "");
}

const HEADER_TO_DB = {
  // Profil / Kategori
  profil: "profil",
  kategori: "profil",
  kategori_aqil: "profil",
  profil_utama: "profil",

  // Kolom utama
  program: "program",
  definisi: "definisi",
  indikator: "indikator",
  sasaran: "sasaran",
  target: "sasaran",
  sasaran_program: "sasaran",
  sasaran_kegiatan: "sasaran",

  sop: "sop",
  instruksi_kerja: "instruksi_kerja",
  instruksi: "instruksi_kerja",
  instruksi_kerja_ik: "instruksi_kerja",

  pic: "pic",
  pj: "pic",
  penanggung_jawab: "pic",

  bukti: "bukti",
  eviden: "bukti",
  evidance: "bukti",

  frekuensi: "frekuensi",
  tahapan: "frekuensi",
};

function resolveDbKey(rawHeader) {
  const nh = normHeader(rawHeader);

  // 1) exact mapping
  if (HEADER_TO_DB[nh]) return HEADER_TO_DB[nh];

  // 2) fallback: contains
  if (nh.includes("sasaran") || nh.includes("target")) return "sasaran";
  if (nh.includes("instruksi") || nh.includes("_ik") || nh === "ik") return "instruksi_kerja";
  if (nh.includes("sop")) return "sop";
  if (nh.includes("frekuensi") || nh.includes("tahapan")) return "frekuensi";
  if (nh.includes("bukti") || nh.includes("eviden")) return "bukti";
  if (nh.includes("pic") || nh.includes("penanggung_jawab") || nh.includes("pj")) return "pic";
  if (nh.includes("indikator")) return "indikator";
  if (nh.includes("definisi")) return "definisi";
  if (nh === "profil") return "profil";

  return null;
}

function makeKey(profil, program) {
  return `${normLower(profil)}||${normLower(program)}`;
}

function setIfBetter(obj, key, val) {
  const v = norm(val);
  if (!v) return;
  if (!obj[key]) obj[key] = v;
}

els.fileExcel.addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  const ok = await askConfirm(
    `Import file "${file.name}"?\nDuplikat (Profil & Program sama) akan di-merge (update otomatis).`
  );
  if (!ok) {
    els.fileExcel.value = "";
    return;
  }

  setStatus("Reading...", "load");
  try {
    const buffer = await file.arrayBuffer();
    const workbook = XLSX.read(buffer, { type: "array" });
    const worksheet = workbook.Sheets[workbook.SheetNames[0]];

    const aoa = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: "" });
    if (!aoa.length) throw new Error("File kosong");

    const rawHeaders = aoa[0] || [];
    const headerMap = rawHeaders.map((h) => resolveDbKey(h));

    // Fetch DB (untuk merge: agar kolom kosong tidak menimpa data lama)
    const { data: dbData, error: dbErr } = await db.from("program_pontren").select("*");
    if (dbErr) throw dbErr;

    const existingMap = new Map();
    (dbData || []).forEach((r) => {
      const p = r.profil || r.profil_utama || "";
      const pr = r.program || "";
      if (!p || !pr) return;
      existingMap.set(makeKey(p, pr), r);
    });

    const stagedMap = new Map();
    let skipped = 0;

    for (let i = 1; i < aoa.length; i++) {
      const line = aoa[i];
      if (!line || line.every((c) => String(c ?? "").trim() === "")) continue;

      const obj = {};
      for (let c = 0; c < headerMap.length; c++) {
        const k = headerMap[c];
        if (!k) continue;
        setIfBetter(obj, k, line[c]);
      }

      const profil = obj.profil || "";
      const program = obj.program || "";
      if (!profil || !program) {
        skipped++;
        continue;
      }

      const key = makeKey(profil, program);
      const old = existingMap.get(key);

      const merged = {
        profil,
        program,
        definisi: (obj.definisi || (old ? (old.definisi || "") : "")),
        indikator: (obj.indikator || (old ? (old.indikator || "") : "")),
        sasaran: (obj.sasaran || (old ? (old.sasaran || "") : "")),
        pic: (obj.pic || (old ? (old.pic || "") : "")),
        frekuensi: (obj.frekuensi || (old ? (old.frekuensi || "") : "")),
        sop: (obj.sop || (old ? (old.sop || "") : "")),
        instruksi_kerja: (obj.instruksi_kerja || (old ? (old.instruksi_kerja || "") : "")),
        bukti: (obj.bukti || (old ? (old.bukti || "") : "")),
      };

      // Rapikan indikator multiline
      if (typeof merged.indikator === "string" && merged.indikator) {
        merged.indikator = merged.indikator
          .split(/\r?\n|;/)
          .map((s) => s.trim())
          .filter(Boolean)
          .join("\n");
      }

      stagedMap.set(key, merged);
    }

    const stagedRows = Array.from(stagedMap.values());
    if (!stagedRows.length) throw new Error("Tidak ada baris valid untuk di-import (cek kolom Profil & Program).");

    let insertCount = 0;
    let updateCount = 0;
    stagedMap.forEach((_, key) => {
      if (existingMap.has(key)) updateCount++;
      else insertCount++;
    });

    const CHUNK = 200;
    for (let i = 0; i < stagedRows.length; i += CHUNK) {
      const chunk = stagedRows.slice(i, i + CHUNK);
      const { error } = await db
        .from("program_pontren")
        .upsert(chunk, { onConflict: "profil,program" });
      if (error) throw error;
    }

    const skippedNote = skipped ? ` (skip ${skipped} baris: profil/program kosong)` : "";
    notify(`Selesai! Baru: ${insertCount}, Update: ${updateCount}${skippedNote}`, "success");

    els.fileExcel.value = "";
    await refreshAllData();
    fetchData();
    setStatus("Ready", "ok");
  } catch (err) {
    console.error(err);
    notify("Gagal Import: " + (err?.message || String(err)), "error");
    setStatus("Error", "err");
    els.fileExcel.value = "";
  }
});

  els.btnAddData.addEventListener("click", () => openModal(null));
  els.btnApply.addEventListener("click", () => {
    if (window.innerWidth < 1024) els.filtersPanel.open = false;
    fetchData();
  });
  els.q.addEventListener("keyup", (e) => {
    if (e.key === "Enter") {
        if (window.innerWidth < 1024) els.filtersPanel.open = false;
        fetchData();
    }
  });
  els.btnReset.addEventListener("click", async () => {
    resetFilters();
    fetchData();
  });
  [
    els.profil,
    els.indikator,
    els.program,
    els.pic,
    els.bukti,
    els.frekuensi,
  ].forEach(el => el && el.addEventListener("change", fetchData));


  // Filter text inputs (SOP & Instruksi Kerja)
  [els.sop, els.instruksi_kerja].forEach(el => {
    if (!el) return;
    el.addEventListener("input", () => {
      fetchData();
    });
    el.addEventListener("keyup", (e) => {
      if (e.key === "Enter") {
        if (window.innerWidth < 1024) els.filtersPanel.open = false;
        fetchData();
      }
    });
  });

  els.btnCloseModal.addEventListener("click", closeModal);
  els.btnCancelEdit.addEventListener("click", closeModal);
  els.btnSaveEdit.addEventListener("click", saveChanges);
  els.btnDeleteData.addEventListener("click", deleteData);
  els.modal.addEventListener("click", (e) => {
    if (e.target === els.modal) closeModal();
  });

  // Quick link: kelola dokumen/record dari modal edit
  els.btnManageDocs?.addEventListener("click", () => {
    closeModal();
    // buka tab terakhir yang dipakai (kalau ada), default SOP
    openDocsModal(activeProgramRow, lastDocsTab || "SOP");
  });

  // Docs modal interactions
  els.btnCloseDocsModal?.addEventListener("click", closeDocsModal);
  els.docsModal?.addEventListener("click", (e) => {
    if (e.target === els.docsModal) closeDocsModal();
  });
  els.tabBtnSOP?.addEventListener("click", () => setDocsTab("SOP"));
  els.tabBtnIK?.addEventListener("click", () => setDocsTab("IK"));
  els.tabBtnREC?.addEventListener("click", () => setDocsTab("REC"));

  // Download template XLSX isi otomatis (prefilled)
  els.btnTemplateSOPPrefill?.addEventListener("click", () => downloadTemplatePrefilled("SOP"));
  els.btnTemplateIKPrefill?.addEventListener("click", () => downloadTemplatePrefilled("IK"));
  els.btnTemplateRECPrefill?.addEventListener("click", () => downloadTemplatePrefilled("REC"));

  // Dropdown template: toggle + close on outside
  const dropdownPairs = [
    { btn: els.btnTplSOP, menu: els.menuTplSOP },
    { btn: els.btnTplIK, menu: els.menuTplIK },
    { btn: els.btnTplREC, menu: els.menuTplREC },
    { btn: els.btnRecAddMenu, menu: els.menuRecAdd },
  ].filter(x => x.btn && x.menu);

  function closeAllDropdowns() {
    dropdownPairs.forEach(({ menu }) => menu.classList.remove("open"));
  }

  dropdownPairs.forEach(({ btn, menu }) => {
    btn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      const nextOpen = !menu.classList.contains("open");
      closeAllDropdowns();
      if (nextOpen) menu.classList.add("open");
    });
    menu.addEventListener("click", (e) => {
      e.stopPropagation();
      const hit = e.target.closest(".dd-item");
      if (hit) closeAllDropdowns();
    });
  });
  document.addEventListener("click", closeAllDropdowns);
  window.addEventListener("resize", closeAllDropdowns);

  // Upload pintar: satu tombol untuk XLSX (parse/source) atau PDF/DOCX (final)
  async function handleSmartUpload(kind, file) {
    if (!file) return;
    const name = file.name || "";
    const isXlsx = isTemplateXlsx(name);
    if (isXlsx) {
      await uploadTemplateParsed(kind, file);
    } else {
      await uploadDoc(kind, file);
    }
  }

  els.btnUploadSOPSmart?.addEventListener("click", () => {
    els.sop_smart_file?.click();
  });
  els.sop_smart_file?.addEventListener("change", async () => {
    const file = els.sop_smart_file?.files?.[0];
    await handleSmartUpload("SOP", file);
    els.sop_smart_file.value = "";
  });

  els.btnUploadIKSmart?.addEventListener("click", () => {
    els.ik_smart_file?.click();
  });
  els.ik_smart_file?.addEventListener("change", async () => {
    const file = els.ik_smart_file?.files?.[0];
    await handleSmartUpload("IK", file);
    els.ik_smart_file.value = "";
  });

  // Record: import XLSX via tombol, tambah manual tetap ada
  els.btnImportREC?.addEventListener("click", () => {
    els.rec_smart_file?.click();
  });
  els.rec_smart_file?.addEventListener("change", async () => {
    const file = els.rec_smart_file?.files?.[0];
    await uploadRecordTemplateParsed(file);
    els.rec_smart_file.value = "";
  });

  els.btnAddRecord?.addEventListener("click", addRecord);

  // Delegasi klik untuk list SOP/IK
  function handleDocsListClick(e) {
    const t = e.target.closest("button");
    if (!t) return;
    if (t.hasAttribute("data-doc-view")) return viewDoc(t.getAttribute("data-doc-view"));
    if (t.hasAttribute("data-doc-toggle")) return toggleDocActive(t.getAttribute("data-doc-toggle"));
    if (t.hasAttribute("data-doc-del")) return deleteDoc(t.getAttribute("data-doc-del"));
    if (t.hasAttribute("data-doc-toggle-group")) return toggleDocActiveGroup(t.getAttribute("data-doc-toggle-group"));
    if (t.hasAttribute("data-doc-del-group")) return deleteDocGroup(t.getAttribute("data-doc-del-group"));
  }
  els.docsListSOP?.addEventListener("click", handleDocsListClick);
  els.docsListIK?.addEventListener("click", handleDocsListClick);

  // Delegasi klik untuk list record
  els.recordsList?.addEventListener("click", (e) => {
    const t = e.target.closest("button");
    if (!t) return;
    if (t.hasAttribute("data-rec-view")) return viewRecord(t.getAttribute("data-rec-view"));
    if (t.hasAttribute("data-rec-del")) return deleteRecord(t.getAttribute("data-rec-del"));
  });

  (async function init() {
    if (window.innerWidth < 1024) els.filtersPanel.open = false;
    await refreshAllData();
    fetchData();
  })();
})();